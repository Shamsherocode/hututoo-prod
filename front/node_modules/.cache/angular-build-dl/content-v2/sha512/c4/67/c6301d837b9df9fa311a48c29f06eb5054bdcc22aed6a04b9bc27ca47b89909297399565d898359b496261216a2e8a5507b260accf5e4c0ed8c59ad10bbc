{"version":3,"sources":["./src/app/maps/fullscreenmap/fullscreenmap.component.html","./src/app/maps/googlemaps/googlemaps.component.ts","./node_modules/@ngui/map/__ivy_ngcc__/esm2015/ngui-map.js","./src/app/maps/fullscreenmap/fullscreenmap.component.ts","./src/app/maps/vectormaps/vectormaps.component.ts","./src/app/maps/googlemaps/googlemaps.component.html","./src/app/maps/maps.routing.ts","./src/app/maps/vectormaps/vectormaps.component.html","./src/app/maps/maps.module.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAe,wLAAyH,aAAa,aAAa,oBAAoB,SAAS,gBAAgB,2CAA2C,8GAA8G,E;;;;;;;;;;;;;;;;;;;;;;;ACAtT;IAWrC,mBAAmB,SAAnB,mBAAmB;IAE5B,QAAQ;IAGR,CAAC;CACJ;AANY,mBAAmB;IAN/B,+DAAS,CAAC;QAEP,QAAQ,EAAE,iBAAiB;QAC3B,uFAA0C;KAC7C,CAAC;GAEW,mBAAmB,CAM/B;AAN+B;;;;;;;;;;;;;ACXhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8M;AACpJ;AACA;AACX;;AAE/C;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,yBAAyB,EAAE,oDAAoD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,oBAAoB,UAAU,aAAa,QAAQ;AACnD;AACA;AACA,qEAAqE,QAAQ;AAC7E,OAAO;AACP;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA;AACA;AACA;AACA,0DAA0D,0DAAY;AACtE;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,CAAC,8DAAuB,GAAG;AACzF,wBAAwB,+DAAwB,EAAE,mCAAmC,+BAA+B,aAAa,kEAA2B,GAAG;AAC/J;AACA,sBAAsB,OAAO,oDAAM,EAAE;AACrC;;;AAGA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,aAAa;AACpF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE,qBAAqB,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,4DAA4D,OAAO;AACnE;AACA,8BAA8B,EAAE,QAAQ;AACxC;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA,8BAA8B,EAAE,QAAQ;AACxC;AACA;AACA;AACA;AACA,+BAA+B,EAAE,iCAAiC,EAAE;AACpE,gCAAgC,EAAE;AAClC;AACA;AACA,8BAA8B,EAAE,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,4BAA4B,EAAE;AAC9B;AACA;AACA,+BAA+B,EAAE;AACjC;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mCAAmC,EAAE;AACrC,6EAA6E,EAAE;AAC/E;AACA;AACA,oFAAoF,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,8BAA8B,EAAE;AAChC;AACA;AACA;AACA,8BAA8B,EAAE,QAAQ;AACxC;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,4BAA4B,EAAE,UAAU,0BAA0B;AAClE,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mCAAmC;AAC3F,sBAAsB,gEAAyB,EAAE,oDAAoD;AACrG,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,oDAAoD;AACpD,mBAAmB,+CAAU;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sEAAsE,0CAA0C;AAChH,6BAA6B,gEAAyB,EAAE,kEAAkE;AAC1H,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA,cAAc,WAAW;AACzB;AACA,gCAAgC,4DAAc;AAC9C;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,wBAAwB,kDAAa;AACrC,sCAAsC;AACtC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,0DAA0D,CAAC,8DAAuB,GAAG;AACrF,sBAAsB,+DAAwB,EAAE,uBAAuB;;AAEvE;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE,0CAA0C,EAAE;AACtE,wBAAwB,EAAE,kCAAkC,kEAAkE;AAC9H;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,oBAAoB,EAAE,2CAA2C,EAAE;AACnE,wBAAwB,EAAE;AAC1B,iDAAiD,0BAA0B,EAAE;AAC7E,aAAa;AACb,wBAAwB,EAAE,kDAAkD,EAAE;AAC9E;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,oFAAoF,+CAA+C,sDAAe,CAAC,oDAAa,GAAG,sDAAe,0BAA0B;AAC5M,oCAAoC,gEAAyB,EAAE,gFAAgF;AAC/I;AACA;AACA,KAAK,OAAO,oDAAM,GAAG;AACrB,KAAK,gCAAgC,OAAO,sDAAQ,EAAE,GAAG,OAAO,oDAAM,gCAAgC,IAAI;AAC1G;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,KAAK,gBAAgB,UAAU,OAAO,oDAAa,EAAE,GAAG;AACxD,sBAAsB,sDAAQ;AAC9B,aAAa;AACb,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,QAAQ,EAAE;AAC9B;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,uCAAuC,sDAAe,0BAA0B;AACpJ,4BAA4B,gEAAyB,EAAE,gEAAgE;AACvH;AACA;AACA,KAAK,gCAAgC,OAAO,sDAAQ,EAAE,GAAG,OAAO,oDAAM,gCAAgC,IAAI;AAC1G;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,KAAK,gBAAgB,UAAU;AAC/B,sBAAsB,sDAAQ;AAC9B,aAAa;AACb,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,QAAQ,EAAE;;AAE9B;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,+CAAU;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8CAA8C,4BAA4B,sDAAe,kBAAkB;AAC3G,iBAAiB,gEAAyB,EAAE,0CAA0C;AACtF;AACA;AACA,KAAK,wBAAwB;AAC7B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,KAAK,gBAAgB,UAAU,uBAAuB,EAAE,EAAE,QAAQ,EAAE;;AAEpE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE,oBAAoB,EAAE,6BAA6B,EAAE;AAClF;AACA,oCAAoC,EAAE;AACtC,0CAA0C,4CAA4C;AACtF;AACA;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,6BAA6B,EAAE,4DAA4D,EAAE;AAC7F;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,6CAA6C,iBAAiB;AAC9D,kCAAkC;AAClC;AACA;AACA,4CAA4C,2BAA2B,sDAAe,YAAY,sDAAe,iBAAiB,sDAAe,CAAC,oDAAa,GAAG;AAClK,gBAAgB,gEAAyB,EAAE,wCAAwC;AACnF;AACA;AACA,KAAK,kBAAkB;AACvB,KAAK,uBAAuB;AAC5B,KAAK,OAAO,oDAAM,GAAG;AACrB;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,KAAK,gBAAgB,UAAU,iBAAiB,GAAG,sBAAsB,GAAG,OAAO,oDAAa,EAAE,EAAE,EAAE,QAAQ,EAAE;;AAEhH;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA,iCAAiC,4CAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0DAAY;AACjE;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB,4DAAK;AACvB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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CA;AACA;AACA;AACA;AACA,mCAAmC,EAAE;AACrC,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE;AACrC,uCAAuC,EAAE;AACzC;AACA;AACA;AACA,uCAAuC,EAAE;AACzC,uCAAuC,EAAE;AACzC,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C,iCAAiC,4CAAO;AACxC;AACA,uDAAuD,0DAAY;AACnE;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAY,QAAQ,0DAAG;AACvD;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,oBAAoB,+DAAwB,CAAC,wDAAiB,GAAG,+DAAwB,WAAW;AAClN,oBAAoB,+DAAwB,EAAE,8DAA8D,uBAAuB,YAAY,myBAAmyB,aAAa,kEAA2B,kGAAkG;AAC5jC,QAAQ,6DAAsB;AAC9B,QAAQ,0DAAmB;AAC3B,KAAK,EAAE,oBAAoB;AAC3B;AACA;AACA,KAAK,0BAA0B;AAC/B,KAAK,OAAO,wDAAU,GAAG;AACzB,KAAK,iBAAiB;AACtB;AACA;AACA,sBAAsB,OAAO,oDAAM,EAAE;AACrC;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,GAAG,OAAO,wDAAiB,EAAE,GAAG,gBAAgB,EAAE,EAAE,GAAG;AAC/G,kBAAkB,oDAAM;AACxB,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,wCAAwC,EAAE,OAAO;AACjD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,wEAAwE,0BAA0B;AAClG;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0CAA0C,0BAA0B,+DAAwB,oBAAoB;AAChH,cAAc,+DAAwB,EAAE,iEAAiE,yYAAyY,YAAY,6SAA6S,aAAa,wEAAiC,GAAG;AAC51B;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6BAA6B,+DAAwB,oBAAoB;AACzH,iBAAiB,+DAAwB,EAAE,wDAAwD,uLAAuL,YAAY,+SAA+S,aAAa,wEAAiC,GAAG;AACtoB;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sCAAsC,+DAAwB,oBAAoB,+DAAwB,wBAAwB;AACpM,0BAA0B,+DAAwB,EAAE,0EAA0E,2eAA2e,YAAY,2CAA2C,aAAa,wEAAiC,EAAE,kEAA2B,GAAG;AAC9uB;AACA;AACA,KAAK,0BAA0B;AAC/B,KAAK,8BAA8B;AACnC;AACA;AACA,2BAA2B,OAAO,mDAAK,iCAAiC;AACxE;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,GAAG,6BAA6B,EAAE,EAAE,GAAG;AAC/F,kBAAkB,mDAAK;AACvB;AACA,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kCAAkC,+DAAwB,oBAAoB;AACxI,sBAAsB,+DAAwB,EAAE,kEAAkE,2TAA2T,YAAY,2NAA2N,aAAa,wEAAiC,GAAG;AACrsB;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,wCAAwC,EAAE,OAAO;AACjD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iCAAiC,+DAAwB,oBAAoB;AACrI,qBAAqB,+DAAwB,EAAE,gEAAgE,2EAA2E,YAAY,uCAAuC,aAAa,wEAAiC,GAAG;AAC9R;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,oBAAoB;AAClI,oBAAoB,+DAAwB,EAAE,8DAA8D,yJAAyJ,aAAa,wEAAiC,GAAG;AACtT;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B,+DAAwB,oBAAoB;AACtH,gBAAgB,+DAAwB,EAAE,sDAAsD,+LAA+L,YAAY,uGAAuG,aAAa,wEAAiC,GAAG;AACnc;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,wCAAwC,EAAE,OAAO;AACjD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,wEAAwE,4BAA4B;AACpG;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0CAA0C,0BAA0B,+DAAwB,oBAAoB;AAChH,cAAc,+DAAwB,EAAE,iDAAiD,6WAA6W,YAAY,ikBAAikB,aAAa,wEAAiC,GAAG;AACpkC;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC,0DAAY;AAC7C,gCAAgC,0DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,4DAAK;AACvB;AACA;AACA;AACA,kEAAkE,sCAAsC,+DAAwB,iBAAiB,+DAAwB,CAAC,wDAAiB,GAAG,+DAAwB,kBAAkB;AACxO,0BAA0B,+DAAwB,EAAE,mFAAmF,mFAAmF,YAAY,+DAA+D,EAAE;AACvS;AACA;AACA,KAAK,uBAAuB;AAC5B,KAAK,OAAO,wDAAU,GAAG;AACzB,KAAK,wBAAwB;AAC7B;AACA;AACA,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,+BAA+B,OAAO,mDAAK,EAAE;AAC7C,eAAe,OAAO,mDAAK,EAAE;AAC7B,uBAAuB,OAAO,oDAAM,4BAA4B;AAChE,sBAAsB,OAAO,oDAAM,EAAE;AACrC;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,sBAAsB,GAAG,OAAO,wDAAiB,EAAE,GAAG,uBAAuB,EAAE,EAAE,GAAG;AACnH,kBAAkB,oDAAM;AACxB;AACA,SAAS;AACT,kBAAkB,oDAAM;AACxB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,4CAA4C,2BAA2B,+DAAwB,oBAAoB;AACnH,eAAe,+DAAwB,EAAE,oEAAoE,uVAAuV,YAAY,6OAA6O,aAAa,wEAAiC,GAAG;AAC9uB;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B,+DAAwB,oBAAoB;AACtH,gBAAgB,+DAAwB,EAAE,qDAAqD,+QAA+Q,YAAY,6OAA6O,aAAa,wEAAiC,GAAG;AACxpB;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sCAAsC,+DAAwB,oBAAoB;AACpJ,0BAA0B,+DAAwB,EAAE,2EAA2E,mxBAAmxB,YAAY,iPAAiP,aAAa,wEAAiC,GAAG;AAChsC;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,yBAAyB,EAAE,EAAE,QAAQ,EAAE;;AAEtE;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,oBAAoB;AAClI,oBAAoB,+DAAwB,EAAE,8DAA8D,iDAAiD,aAAa,wEAAiC,GAAG;AAC9M;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;A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","file":"maps-maps-module-es2015.js","sourcesContent":["export default \"<div class=\\\"main-content\\\">\\n\\n          <ngui-map zoom=\\\"13\\\" center=\\\"40.748817,-73.985428\\\" style=\\\"margin-top:60px;height: 100%; width: 100%; position: absolute;top: 0px;\\n    left: 0px;\\n    background-color: rgb(229, 227, 223);\\\">\\n              <marker [position]=\\\"[40.748817,-73.985428]\\\"></marker>\\n          </ngui-map>\\n\\n</div>\\n\";","import { Component, OnInit } from '@angular/core';\n\ndeclare var google: any;\ndeclare var $: any;\n\n@Component({\n    moduleId: module.id,\n    selector: 'vector-maps-cmp',\n    templateUrl: './googlemaps.component.html'\n})\n\nexport class GoogleMapsComponent implements OnInit{\n\n    ngOnInit(){\n    \n\n    }\n}\n","import { EventEmitter, Output, Injectable, InjectionToken, Inject, Optional, NgZone, Component, ElementRef, ViewEncapsulation, Directive, ViewChild, ViewContainerRef, Input, NgModule } from '@angular/core';\nimport { Observable, ReplaySubject, Subject } from 'rxjs';\nimport { debounceTime, tap, first } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * return json string from json-like string\n * @param {?} str\n * @return {?}\n */\nimport * as ɵngcc0 from '@angular/core';\n\nconst _c0 = [\"*\"];\nconst _c1 = [\"template\"];\nfunction jsonize(str) {\n    try {\n        // if parsable already, return as it is\n        JSON.parse(str);\n        return str;\n    }\n    catch (/** @type {?} */ e) {\n        // if not parsable, change little\n        return str\n            .replace(/([\\$\\w]+)\\s*:/g, // wrap keys without double quote\n        // wrap keys without double quote\n        function (_, $1) {\n            return '\"' + $1 + '\":';\n        })\n            .replace(/'([^']+)'/g, // replacing single quote to double quote\n        // replacing single quote to double quote\n        function (_, $1) {\n            return '\"' + $1 + '\"';\n        });\n    }\n}\n/**\n * Returns string to an object by using JSON.parse()\n * @param {?} input\n * @return {?}\n */\nfunction getJSON(input) {\n    if (typeof input === 'string') {\n        const /** @type {?} */ re = /^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; // lat,lng\n        if (input.match(re)) {\n            input = '[' + input + ']';\n        }\n        return JSON.parse(jsonize(input));\n    }\n    else {\n        return input;\n    }\n}\n/**\n * json type definition\n * @record\n */\n\n/**\n * Returns camel-cased from string 'Foo Bar' to 'fooBar'\n * @param {?} str\n * @return {?}\n */\nfunction toCamelCase(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (letter, index) {\n        return index === 0 ? letter.toLowerCase() : letter.toUpperCase();\n    }).replace(/\\s+/g, '');\n}\n/**\n * @return {?}\n */\nfunction isMapsApiLoaded() {\n    return typeof google === 'object' && typeof google.maps === 'object';\n}\n/**\n * @param {?} component\n * @param {?} libName\n * @return {?}\n */\nfunction missingLibraryError(component, libName) {\n    return Error(`${component}: library '${libName}' is missing, please ensure to include it in a 'libraries' parameter.\n    Example:\n      NguiMapModule.forRoot({\n        apiUrl: 'https://maps.googleapis.com/maps/api/js?libraries=${libName}'\n      })\n  `);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nclass BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} mapObjectName\n     * @param {?} inputs\n     * @param {?} outputs\n     */\n    constructor(nguiMapComponent, mapObjectName, inputs, outputs) {\n        this.nguiMapComponent = nguiMapComponent;\n        this.mapObjectName = mapObjectName;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        // this should be redefined on each childr directive\n        this.initialized$ = new EventEmitter();\n        this._subscriptions = [];\n        this.nguiMap = this.nguiMapComponent['nguiMap'];\n        this.optionBuilder = this.nguiMapComponent['optionBuilder'];\n        // all outputs must be initialized\n        this.outputs.forEach(output => this[output] = new EventEmitter());\n        this.mapObjectName = mapObjectName;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            // map is ready already\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        // will be set after geocoded\n        typeof this.objectOptions.position === 'string' && (delete this.objectOptions.position);\n        typeof this.objectOptions.center === 'string' && (delete this.objectOptions.center);\n        // noinspection TypeScriptUnresolvedFunction\n        if (this.libraryName) {\n            if (!google.maps[this.libraryName]) {\n                throw missingLibraryError(this.mapObjectName, this.libraryName);\n            }\n            this.mapObject = new google.maps[this.libraryName][this.mapObjectName](this.objectOptions);\n        }\n        else {\n            this.mapObject = new google.maps[this.mapObjectName](this.objectOptions);\n        }\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        this.mapObject['nguiMapComponent'] = this.nguiMapComponent;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.nguiMap.updateGoogleObject(this.mapObject, changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._subscriptions.map(subscription => subscription.unsubscribe());\n        this.nguiMapComponent.removeFromMapObjectGroup(this.mapObjectName, this.mapObject);\n        if (this.mapObject) {\n            this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n        }\n    }\n}\nBaseMapDirective.ɵfac = function BaseMapDirective_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };\nBaseMapDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseMapDirective, outputs: { initialized$: \"initialized$\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\nBaseMapDirective.propDecorators = {\n    \"initialized$\": [{ type: Output },],\n};\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * change any object to google object options\n * e.g. [1,2] -> new google.maps.LatLng(1,2);\n */\nclass OptionBuilder {\n    /**\n     * @param {?} definedInputs\n     * @param {?} userInputs\n     * @return {?}\n     */\n    googlizeAllInputs(definedInputs, userInputs) {\n        let /** @type {?} */ options = {};\n        // if options given from user, only take options and ignore other inputs\n        if (userInputs.options) {\n            options = userInputs.options;\n            if (!this.onlyOptionsGiven(definedInputs, userInputs)) {\n                console.error('when \"options\" are used, other options are ignored');\n            }\n        }\n        else {\n            // if options not given, process all user inputs\n            definedInputs.forEach(input => {\n                if (userInputs[input] !== undefined) {\n                    options[input] = this.googlize(userInputs[input], { key: input });\n                }\n            });\n        }\n        return options;\n    }\n    /**\n     * @param {?} inputs\n     * @param {?=} options\n     * @return {?}\n     */\n    googlizeMultiple(inputs, options) {\n        options = options || {};\n        for (let /** @type {?} */ key in inputs) {\n            let /** @type {?} */ val = inputs[key];\n            // (non-strings are fully converted)\n            if (typeof val !== 'string') {\n                options[key] = val;\n            }\n            else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {\n                options[key] = this.googlize(val, { key: key });\n            }\n        } // for(var key in attrs)\n        return options;\n    }\n    /**\n     * @param {?} input\n     * @param {?=} options\n     * @return {?}\n     */\n    googlize(input, options) {\n        options = options || {};\n        let /** @type {?} */ output = input;\n        if (typeof input === 'string') {\n            // convert string to a google object\n            if (input === 'false') {\n                output = false;\n            }\n            else if (input === '0') {\n                output = 0;\n            }\n            else {\n                output =\n                    // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed\n                    this.getJSONParsed(input, options)\n                        /* Foo.Bar(...) -> new google.maps.Foo.Bar(...) */\n                        || this.getAnyMapObject(input)\n                        /*  MapTypeID.HYBRID -> new google.maps.MapTypeID.HYBRID */\n                        || this.getAnyMapConstant(input, options)\n                        /*  2016-06-20 -> new Date('2016-06-20') */\n                        || this.getDateObject(input)\n                        || input;\n            }\n        }\n        if (options['key']) {\n            let /** @type {?} */ key = /** @type {?} */ (options['key']);\n            if (output instanceof Array) {\n                // e.g., [1, 2]\n                if (key === 'bounds') {\n                    output = new google.maps.LatLngBounds(output[0], output[1]);\n                }\n                else if (key === 'icons') {\n                    output = this.getMapIcons(output);\n                }\n                else if (key === 'position' || key.match(/^geoFallback/)) {\n                    output = this.getLatLng(output);\n                }\n            }\n            else if (output instanceof Object) {\n                if (key === 'icon') {\n                    output = this.getMarkerIcon(output);\n                }\n                else if (key.match(/ControlOptions$/)) {\n                    output = this.getMapControlOption(output);\n                }\n            }\n        }\n        // delete keys only for processing, not used by google\n        delete output['doNotConverStringToNumber'];\n        delete output['key'];\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getLatLng(input) {\n        let /** @type {?} */ output;\n        if (input[0].constructor === Array) {\n            // [[1,2],[3,4]]\n            output = (/** @type {?} */ (input)).map((el) => new google.maps.LatLng(el[0], el[1]));\n        }\n        else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n            output = new google.maps.LatLng(input[0], input[1]);\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @param {?} options\n     * @return {?}\n     */\n    getJSONParsed(input, options) {\n        let /** @type {?} */ output;\n        try {\n            output = getJSON(input);\n            if (output instanceof Array) {\n                // [{a:1}] : not lat/lng ones\n                if (output[0].constructor !== Object) {\n                    // [[1,2],[3,4]] or [1,2]\n                    output = this.getLatLng(output);\n                }\n            }\n            else if (output === Object(output)) {\n                // check for nested hashes and convert to Google API options\n                let /** @type {?} */ newOptions = options;\n                newOptions['doNotConverStringToNumber'] = true;\n                output = this.googlizeMultiple(output, newOptions);\n            }\n        }\n        catch (/** @type {?} */ e) {\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getAnyMapObject(input) {\n        let /** @type {?} */ output;\n        if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n            try {\n                output = Function(`return new google.maps.${input};`)();\n            }\n            catch (/** @type {?} */ e) { }\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @param {?} options\n     * @return {?}\n     */\n    getAnyMapConstant(input, options) {\n        let /** @type {?} */ output;\n        if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n            // e.g. MapTypeID.HYBRID\n            try {\n                let /** @type {?} */ matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n                output = google.maps[matches[1]][matches[2]];\n            }\n            catch (/** @type {?} */ e) { }\n        }\n        else if (input.match(/^[A-Z]+$/)) {\n            // e.g. HYBRID\n            try {\n                let /** @type {?} */ capitalizedKey = (/** @type {?} */ (options['key'])).charAt(0).toUpperCase() +\n                    (/** @type {?} */ (options['key'])).slice(1);\n                output = google.maps[capitalizedKey][input];\n            }\n            catch (/** @type {?} */ e) { }\n        }\n        return output;\n    }\n    /**\n     * streetviewControl, panControl, etc, not a general control\n     * @param {?} controlOptions\n     * @return {?}\n     */\n    getMapControlOption(controlOptions) {\n        let /** @type {?} */ newControlOptions = controlOptions;\n        for (let /** @type {?} */ key in newControlOptions) {\n            // assign the right values\n            if (newControlOptions[key]) {\n                let /** @type {?} */ value = newControlOptions[key];\n                if (typeof value === 'string') {\n                    value = (/** @type {?} */ (value)).toUpperCase();\n                }\n                else if (key === 'mapTypeIds') {\n                    value = (/** @type {?} */ (value)).map(function (str) {\n                        if (str.match(/^[A-Z]+$/)) {\n                            // if constant\n                            return google.maps.MapTypeId[str.toUpperCase()];\n                        }\n                        else {\n                            // else, custom map-type\n                            return str;\n                        }\n                    });\n                }\n                if (key === 'style') {\n                    let /** @type {?} */ objName = key.replace(/Options$/, '') + 'Style';\n                    newControlOptions[key] = google.maps[objName][/** @type {?} */ (value)];\n                }\n                else if (key === 'position') {\n                    newControlOptions[key] = google.maps.ControlPosition[/** @type {?} */ (value)];\n                }\n                else {\n                    newControlOptions[key] = value;\n                }\n            }\n        }\n        return newControlOptions;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getDateObject(input) {\n        let /** @type {?} */ output;\n        if (input.match(/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/)) {\n            try {\n                output = new Date(input);\n            }\n            catch (/** @type {?} */ e) { }\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getMapIcons(input) {\n        return input.map(el => {\n            if (el.icon.path.match(/^[A-Z_]+$/)) {\n                el.icon.path = google.maps.SymbolPath[el.icon.path];\n            }\n            return el;\n        });\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getMarkerIcon(input) {\n        let /** @type {?} */ output = input;\n        if (('' + output.path).match(/^[A-Z_]+$/)) {\n            output.path = google.maps.SymbolPath[output.path];\n        }\n        for (let /** @type {?} */ key in output) {\n            let /** @type {?} */ arr = output[key];\n            if (key === 'anchor' || key === 'origin' || key === 'labelOrigin') {\n                output[key] = new google.maps.Point(arr[0], arr[1]);\n            }\n            else if (key === 'size' || key === 'scaledSize') {\n                output[key] = new google.maps.Size(arr[0], arr[1]);\n            }\n        }\n        return output;\n    }\n    /**\n     * @param {?} definedInputs\n     * @param {?} userInputs\n     * @return {?}\n     */\n    onlyOptionsGiven(definedInputs, userInputs) {\n        for (let /** @type {?} */ i = 0; i < definedInputs.length; i++) {\n            let /** @type {?} */ input = definedInputs[i];\n            if (input !== 'options' && typeof userInputs[input] !== 'undefined') {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nOptionBuilder.ɵfac = function OptionBuilder_Factory(t) { return new (t || OptionBuilder)(); };\nOptionBuilder.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: OptionBuilder, factory: OptionBuilder.ɵfac });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OptionBuilder, [{\n        type: Injectable\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n *  service for navigator.geolocation methods\n */\nclass NavigatorGeolocation {\n    /**\n     * @param {?=} geoLocationOptions\n     * @return {?}\n     */\n    getCurrentPosition(geoLocationOptions) {\n        geoLocationOptions = geoLocationOptions || { timeout: 5000 };\n        return new Observable((responseObserver) => {\n            if (navigator.geolocation) {\n                navigator.geolocation.getCurrentPosition((position) => {\n                    responseObserver.next(position);\n                    responseObserver.complete();\n                }, (evt) => responseObserver.error(evt), geoLocationOptions);\n            }\n            else {\n                responseObserver.error('Browser Geolocation service failed.');\n            }\n        });\n    }\n}\nNavigatorGeolocation.ɵfac = function NavigatorGeolocation_Factory(t) { return new (t || NavigatorGeolocation)(); };\nNavigatorGeolocation.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NavigatorGeolocation, factory: NavigatorGeolocation.ɵfac });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigatorGeolocation, [{\n        type: Injectable\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst NG_MAP_CONFIG_TOKEN = new InjectionToken('NG_MAP_CONFIG_TOKEN');\n/**\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nclass NgMapApiLoader {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n        this.config = config;\n        this.api$ = new ReplaySubject(1);\n        this.config = this.config || { apiUrl: 'https://maps.google.com/maps/api/js' };\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.api$.complete();\n    }\n}\nNgMapApiLoader.ɵfac = function NgMapApiLoader_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };\nNgMapApiLoader.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgMapApiLoader });\n\nclass NgMapAsyncCallbackApiLoader extends NgMapApiLoader {\n    /**\n     * @param {?} zone\n     * @param {?} config\n     */\n    constructor(zone, config) {\n        super(config);\n        this.zone = zone;\n    }\n    /**\n     * @return {?}\n     */\n    load() {\n        if (typeof window === 'undefined') {\n            return;\n        }\n        if (isMapsApiLoaded()) {\n            this.api$.next(google.maps);\n        }\n        else if (!document.querySelector('#ngui-map-api')) {\n            (/** @type {?} */ (window))['nguiMapRef'] = (/** @type {?} */ (window))['nguiMapRef'] || [];\n            (/** @type {?} */ (window))['nguiMapRef'].push({ zone: this.zone, componentFn: () => this.api$.next(google.maps) });\n            this.addGoogleMapsApi();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    addGoogleMapsApi() {\n        (/** @type {?} */ (window))['initNguiMap'] = (/** @type {?} */ (window))['initNguiMap'] || function () {\n            (/** @type {?} */ (window))['nguiMapRef'].forEach(nguiMapRef => {\n                nguiMapRef.zone.run(function () { nguiMapRef.componentFn(); });\n            });\n            (/** @type {?} */ (window))['nguiMapRef'].splice(0, (/** @type {?} */ (window))['nguiMapRef'].length);\n        };\n        let /** @type {?} */ script = document.createElement('script');\n        script.id = 'ngui-map-api';\n        // script.src = \"https://maps.google.com/maps/api/js?callback=initNguiMap\";\n        let /** @type {?} */ apiUrl = this.config.apiUrl;\n        apiUrl += apiUrl.indexOf('?') !== -1 ? '&' : '?';\n        script.src = apiUrl + 'callback=initNguiMap';\n        document.querySelector('body').appendChild(script);\n    }\n}\nNgMapAsyncCallbackApiLoader.ɵfac = function NgMapAsyncCallbackApiLoader_Factory(t) { return new (t || NgMapAsyncCallbackApiLoader)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NG_MAP_CONFIG_TOKEN, 8)); };\nNgMapAsyncCallbackApiLoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgMapAsyncCallbackApiLoader, factory: NgMapAsyncCallbackApiLoader.ɵfac });\n/** @nocollapse */\nNgMapAsyncCallbackApiLoader.ctorParameters = () => [\n    { type: NgZone, },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_MAP_CONFIG_TOKEN,] },] },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgMapAsyncCallbackApiLoader, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [NG_MAP_CONFIG_TOKEN]\n            }] }]; }, null); })();\nclass NgMapAsyncApiLoader extends NgMapApiLoader {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * @return {?}\n     */\n    load() {\n        if (typeof window === 'undefined') {\n            return;\n        }\n        if (isMapsApiLoaded()) {\n            this.api$.next(google.maps);\n        }\n        else if (!document.querySelector('#ngui-map-api')) {\n            let /** @type {?} */ script = document.createElement('script');\n            script.id = 'ngui-map-api';\n            script.async = true;\n            script.onload = () => this.api$.next(google.maps);\n            script.src = this.config.apiUrl;\n            document.querySelector('body').appendChild(script);\n        }\n    }\n}\nNgMapAsyncApiLoader.ɵfac = function NgMapAsyncApiLoader_Factory(t) { return new (t || NgMapAsyncApiLoader)(ɵngcc0.ɵɵinject(NG_MAP_CONFIG_TOKEN, 8)); };\nNgMapAsyncApiLoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgMapAsyncApiLoader, factory: NgMapAsyncApiLoader.ɵfac });\n/** @nocollapse */\nNgMapAsyncApiLoader.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_MAP_CONFIG_TOKEN,] },] },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgMapAsyncApiLoader, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [NG_MAP_CONFIG_TOKEN]\n            }] }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *   service for Google Geocoder service\n */\nclass GeoCoder {\n    /**\n     * @param {?} apiLoader\n     */\n    constructor(apiLoader) {\n        this.apiLoader = apiLoader;\n        this.apiLoaderSubs = [];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    geocode(options) {\n        return new Observable((responseObserver) => {\n            this.apiLoaderSubs.push(this.apiLoader.api$\n                .subscribe(() => this.requestGeocode(options, responseObserver)));\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.apiLoaderSubs.map(sub => sub.unsubscribe());\n    }\n    /**\n     * @param {?} options\n     * @param {?} observer\n     * @return {?}\n     */\n    requestGeocode(options, observer) {\n        const /** @type {?} */ geocoder = new google.maps.Geocoder();\n        geocoder.geocode(options, function (results, status) {\n            if (status === google.maps.GeocoderStatus.OK) {\n                observer.next(results);\n                observer.complete();\n            }\n            else {\n                observer.error(results);\n            }\n        });\n    }\n}\nGeoCoder.ɵfac = function GeoCoder_Factory(t) { return new (t || GeoCoder)(ɵngcc0.ɵɵinject(NgMapApiLoader)); };\nGeoCoder.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: GeoCoder, factory: GeoCoder.ɵfac });\n/** @nocollapse */\nGeoCoder.ctorParameters = () => [\n    { type: NgMapApiLoader, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GeoCoder, [{\n        type: Injectable\n    }], function () { return [{ type: NgMapApiLoader }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * collection of map instance-related properties and methods\n */\nclass NguiMap {\n    /**\n     * @param {?} geoCoder\n     * @param {?} optionBuilder\n     * @param {?} zone\n     */\n    constructor(geoCoder, optionBuilder, zone) {\n        this.geoCoder = geoCoder;\n        this.optionBuilder = optionBuilder;\n        this.zone = zone;\n        this.updateGoogleObject = (object, changes) => {\n            let /** @type {?} */ val, /** @type {?} */ currentValue, /** @type {?} */ setMethodName;\n            if (object) {\n                for (let /** @type {?} */ key in changes) {\n                    setMethodName = `set${key.replace(/^[a-z]/, x => x.toUpperCase())}`;\n                    currentValue = changes[key].currentValue;\n                    if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {\n                        // To preserve setMethod name in Observable callback, wrap it as a function, then execute\n                        ((setMethodName) => {\n                            this.geoCoder.geocode({ address: currentValue }).subscribe(results => {\n                                if (typeof object[setMethodName] === 'function') {\n                                    object[setMethodName](results[0].geometry.location);\n                                }\n                                else {\n                                    console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' +\n                                        'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n                                }\n                            });\n                        })(setMethodName);\n                    }\n                    else {\n                        val = this.optionBuilder.googlize(currentValue);\n                        if (typeof object[setMethodName] === 'function') {\n                            object[setMethodName](val);\n                        }\n                        else {\n                            console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' +\n                                'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n                        }\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * @param {?} definedEvents\n     * @param {?} thisObj\n     * @param {?} prefix\n     * @return {?}\n     */\n    setObjectEvents(definedEvents, thisObj, prefix) {\n        definedEvents.forEach(definedEvent => {\n            const /** @type {?} */ eventName = this.getEventName(definedEvent), /** @type {?} */\n            zone = this.zone;\n            zone.runOutsideAngular(() => {\n                thisObj[prefix].addListener(eventName, function (event) {\n                    let /** @type {?} */ param = event ? event : {};\n                    param.target = this;\n                    zone.run(() => thisObj[definedEvent].emit(param));\n                });\n            });\n        });\n    }\n    /**\n     * @param {?} definedEvents\n     * @param {?} thisObj\n     * @param {?} prefix\n     * @return {?}\n     */\n    clearObjectEvents(definedEvents, thisObj, prefix) {\n        definedEvents.forEach(definedEvent => {\n            const /** @type {?} */ eventName = this.getEventName(definedEvent);\n            this.zone.runOutsideAngular(() => {\n                if (thisObj[prefix]) {\n                    google.maps.event.clearListeners(thisObj[prefix], eventName);\n                }\n            });\n        });\n        if (thisObj[prefix]) {\n            if (thisObj[prefix].setMap) {\n                thisObj[prefix].setMap(null);\n            }\n            delete thisObj[prefix].nguiMapComponent;\n            delete thisObj[prefix];\n        }\n    }\n    /**\n     * @param {?} definedEvent\n     * @return {?}\n     */\n    getEventName(definedEvent) {\n        return definedEvent\n            .replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`) // positionChanged -> position_changed\n            .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts\n    }\n}\nNguiMap.ɵfac = function NguiMap_Factory(t) { return new (t || NguiMap)(ɵngcc0.ɵɵinject(GeoCoder), ɵngcc0.ɵɵinject(OptionBuilder), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };\nNguiMap.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NguiMap, factory: NguiMap.ɵfac });\n/** @nocollapse */\nNguiMap.ctorParameters = () => [\n    { type: GeoCoder, },\n    { type: OptionBuilder, },\n    { type: NgZone, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NguiMap, [{\n        type: Injectable\n    }], function () { return [{ type: GeoCoder }, { type: OptionBuilder }, { type: ɵngcc0.NgZone }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS = [\n    'backgroundColor', 'center', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor',\n    'draggingCursor', 'heading', 'keyboardShortcuts', 'mapMaker', 'mapTypeControl', 'mapTypeId', 'maxZoom', 'minZoom',\n    'noClear', 'overviewMapControl', 'panControl', 'panControlOptions', 'rotateControl', 'scaleControl', 'scrollwheel',\n    'streetView', 'styles', 'tilt', 'zoom', 'streetViewControl', 'zoomControl', 'zoomControlOptions', 'mapTypeControlOptions',\n    'overviewMapControlOptions', 'rotateControlOptions', 'scaleControlOptions', 'streetViewControlOptions', 'fullscreenControl', 'fullscreenControlOptions',\n    'options',\n    'geoFallbackCenter'\n];\nconst OUTPUTS = [\n    'bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle',\n    'maptypeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick',\n    'tilesloaded', 'tile_changed', 'zoom_changed',\n    'mapClick', 'mapMouseover', 'mapMouseout', 'mapMousemove', 'mapDrag', 'mapDragend', 'mapDragstart'\n];\nclass NguiMapComponent {\n    /**\n     * @param {?} optionBuilder\n     * @param {?} elementRef\n     * @param {?} geolocation\n     * @param {?} geoCoder\n     * @param {?} nguiMap\n     * @param {?} apiLoader\n     * @param {?} zone\n     */\n    constructor(optionBuilder, elementRef, geolocation, geoCoder, nguiMap, apiLoader, zone) {\n        this.optionBuilder = optionBuilder;\n        this.elementRef = elementRef;\n        this.geolocation = geolocation;\n        this.geoCoder = geoCoder;\n        this.nguiMap = nguiMap;\n        this.apiLoader = apiLoader;\n        this.zone = zone;\n        this.mapReady$ = new EventEmitter();\n        this.mapOptions = {};\n        this.inputChanges$ = new Subject();\n        this.infoWindows = {};\n        this.mapIdledOnce = false;\n        this.initializeMapAfterDisplayed = false;\n        apiLoader.load();\n        // all outputs needs to be initialized,\n        // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n        OUTPUTS.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this.apiLoaderSub = this.apiLoader.api$\n            .pipe(first())\n            .subscribe(() => this.initializeMap());\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewChecked() {\n        if (this.initializeMapAfterDisplayed && this.el && this.el.offsetWidth > 0) {\n            this.initializeMap();\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    initializeMap() {\n        this.el = this.elementRef.nativeElement.querySelector('.google-map');\n        if (this.el && this.el.offsetWidth === 0) {\n            this.initializeMapAfterDisplayed = true;\n            return;\n        }\n        this.initializeMapAfterDisplayed = false;\n        this.mapOptions = this.optionBuilder.googlizeAllInputs(INPUTS, this);\n        this.mapOptions.zoom = this.mapOptions.zoom || 15;\n        typeof this.mapOptions.center === 'string' && (delete this.mapOptions.center);\n        this.zone.runOutsideAngular(() => {\n            this.map = new google.maps.Map(this.el, this.mapOptions);\n            this.map['mapObjectName'] = 'NguiMapComponent';\n            if (!this.mapOptions.center) {\n                // if center is not given as lat/lng\n                this.setCenter();\n            }\n            // set google events listeners and emits to this outputs listeners\n            this.nguiMap.setObjectEvents(OUTPUTS, this, 'map');\n            this.map.addListener('idle', () => {\n                if (!this.mapIdledOnce) {\n                    this.mapIdledOnce = true;\n                    setTimeout(() => {\n                        // Why????, subsribe and emit must not be in the same cycle???\n                        this.mapReady$.emit(this.map);\n                    });\n                }\n            });\n            // update map when input changes\n            this.inputChanges$.pipe(debounceTime(1000), tap((changes) => this.nguiMap.updateGoogleObject(this.map, changes))).subscribe();\n            if (typeof window !== 'undefined' && (/** @type {?} */ (window))['nguiMapRef']) {\n                // expose map object for test and debugging on (<any>window)\n                (/** @type {?} */ (window))['nguiMapRef'].map = this.map;\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    setCenter() {\n        if (!this['center']) {\n            // center is not from user. Thus, we set the current location\n            this.geolocation.getCurrentPosition().subscribe(position => {\n                let /** @type {?} */ latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n                this.map.setCenter(latLng);\n            }, error => {\n                console.error('ngui-map: Error finding the current position');\n                this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            });\n        }\n        else if (typeof this['center'] === 'string') {\n            this.geoCoder.geocode({ address: this['center'] }).subscribe(results => {\n                this.map.setCenter(results[0].geometry.location);\n            }, error => {\n                this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            });\n        }\n    }\n    /**\n     * @param {?} id\n     * @param {?} anchor\n     * @return {?}\n     */\n    openInfoWindow(id, anchor) {\n        this.infoWindows[id].open(anchor);\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    closeInfoWindow(id) {\n        // if infoWindow for id exists, close the infoWindow\n        if (this.infoWindows[id])\n            this.infoWindows[id].close();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.inputChanges$.complete();\n        if (this.el && !this.initializeMapAfterDisplayed) {\n            this.nguiMap.clearObjectEvents(OUTPUTS, this, 'map');\n        }\n        if (this.apiLoaderSub) {\n            this.apiLoaderSub.unsubscribe();\n        }\n    }\n    /**\n     * @param {?} mapObjectName\n     * @param {?} mapObject\n     * @return {?}\n     */\n    addToMapObjectGroup(mapObjectName, mapObject) {\n        let /** @type {?} */ groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n        this.map[groupName] = this.map[groupName] || [];\n        this.map[groupName].push(mapObject);\n    }\n    /**\n     * @param {?} mapObjectName\n     * @param {?} mapObject\n     * @return {?}\n     */\n    removeFromMapObjectGroup(mapObjectName, mapObject) {\n        let /** @type {?} */ groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n        if (this.map && this.map[groupName]) {\n            let /** @type {?} */ index = this.map[groupName].indexOf(mapObject);\n            (index > -1) && this.map[groupName].splice(index, 1);\n        }\n    }\n}\nNguiMapComponent.ɵfac = function NguiMapComponent_Factory(t) { return new (t || NguiMapComponent)(ɵngcc0.ɵɵdirectiveInject(OptionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigatorGeolocation), ɵngcc0.ɵɵdirectiveInject(GeoCoder), ɵngcc0.ɵɵdirectiveInject(NguiMap), ɵngcc0.ɵɵdirectiveInject(NgMapApiLoader), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nNguiMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NguiMapComponent, selectors: [[\"ngui-map\"]], inputs: { backgroundColor: \"backgroundColor\", center: \"center\", disableDefaultUI: \"disableDefaultUI\", disableDoubleClickZoom: \"disableDoubleClickZoom\", draggable: \"draggable\", draggableCursor: \"draggableCursor\", draggingCursor: \"draggingCursor\", heading: \"heading\", keyboardShortcuts: \"keyboardShortcuts\", mapMaker: \"mapMaker\", mapTypeControl: \"mapTypeControl\", mapTypeId: \"mapTypeId\", maxZoom: \"maxZoom\", minZoom: \"minZoom\", noClear: \"noClear\", overviewMapControl: \"overviewMapControl\", panControl: \"panControl\", panControlOptions: \"panControlOptions\", rotateControl: \"rotateControl\", scaleControl: \"scaleControl\", scrollwheel: \"scrollwheel\", streetView: \"streetView\", styles: \"styles\", tilt: \"tilt\", zoom: \"zoom\", streetViewControl: \"streetViewControl\", zoomControl: \"zoomControl\", zoomControlOptions: \"zoomControlOptions\", mapTypeControlOptions: \"mapTypeControlOptions\", overviewMapControlOptions: \"overviewMapControlOptions\", rotateControlOptions: \"rotateControlOptions\", scaleControlOptions: \"scaleControlOptions\", streetViewControlOptions: \"streetViewControlOptions\", fullscreenControl: \"fullscreenControl\", fullscreenControlOptions: \"fullscreenControlOptions\", options: \"options\", geoFallbackCenter: \"geoFallbackCenter\" }, outputs: { bounds_changed: \"bounds_changed\", center_changed: \"center_changed\", click: \"click\", dblclick: \"dblclick\", drag: \"drag\", dragend: \"dragend\", dragstart: \"dragstart\", heading_changed: \"heading_changed\", idle: \"idle\", maptypeid_changed: \"maptypeid_changed\", mousemove: \"mousemove\", mouseout: \"mouseout\", mouseover: \"mouseover\", projection_changed: \"projection_changed\", resize: \"resize\", rightclick: \"rightclick\", tilesloaded: \"tilesloaded\", tile_changed: \"tile_changed\", zoom_changed: \"zoom_changed\", mapClick: \"mapClick\", mapMouseover: \"mapMouseover\", mapMouseout: \"mapMouseout\", mapMousemove: \"mapMousemove\", mapDrag: \"mapDrag\", mapDragend: \"mapDragend\", mapDragstart: \"mapDragstart\", mapReady$: \"mapReady$\" }, features: [ɵngcc0.ɵɵProvidersFeature([NguiMap, OptionBuilder, GeoCoder, NavigatorGeolocation]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, \"google-map\"]], template: function NguiMapComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n    } }, styles: [\"\\n    ngui-map {display: block; height: 300px;}\\n    .google-map {width: 100%; height: 100%}\\n  \"], encapsulation: 2 });\n/** @nocollapse */\nNguiMapComponent.ctorParameters = () => [\n    { type: OptionBuilder, },\n    { type: ElementRef, },\n    { type: NavigatorGeolocation, },\n    { type: GeoCoder, },\n    { type: NguiMap, },\n    { type: NgMapApiLoader, },\n    { type: NgZone, },\n];\nNguiMapComponent.propDecorators = {\n    \"mapReady$\": [{ type: Output },],\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NguiMapComponent, [{\n        type: Component,\n        args: [{\n                selector: 'ngui-map',\n                providers: [NguiMap, OptionBuilder, GeoCoder, NavigatorGeolocation],\n                styles: [`\n    ngui-map {display: block; height: 300px;}\n    .google-map {width: 100%; height: 100%}\n  `],\n                inputs: INPUTS,\n                outputs: OUTPUTS,\n                encapsulation: ViewEncapsulation.None,\n                template: `\n    <div class=\"google-map\"></div>\n    <ng-content></ng-content>\n  `\n            }]\n    }], function () { return [{ type: OptionBuilder }, { type: ɵngcc0.ElementRef }, { type: NavigatorGeolocation }, { type: GeoCoder }, { type: NguiMap }, { type: NgMapApiLoader }, { type: ɵngcc0.NgZone }]; }, { mapReady$: [{\n            type: Output\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$1 = [];\nconst OUTPUTS$1 = [];\nclass BicyclingLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'BicyclingLayer', INPUTS$1, OUTPUTS$1);\n    }\n}\nBicyclingLayer.ɵfac = function BicyclingLayer_Factory(t) { return new (t || BicyclingLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nBicyclingLayer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BicyclingLayer, selectors: [[\"bicycling-layer\"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nBicyclingLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BicyclingLayer, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > bicycling-layer',\n                inputs: INPUTS$1,\n                outputs: OUTPUTS$1\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$2 = [\n    'content', 'disableAutoPan', 'maxWidth', 'pixelOffset', 'position', 'zIndex', 'options'\n];\nconst OUTPUTS$2 = [\n    'closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'\n];\nclass InfoWindow {\n    /**\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     * @param {?} nguiMapComponent\n     */\n    constructor(elementRef, nguiMap, nguiMapComponent) {\n        this.elementRef = elementRef;\n        this.nguiMap = nguiMap;\n        this.nguiMapComponent = nguiMapComponent;\n        this.initialized$ = new EventEmitter();\n        this.objectOptions = {};\n        this.inputChanges$ = new Subject();\n        this.elementRef.nativeElement.style.display = 'none';\n        OUTPUTS$2.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            // map is ready already\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.nguiMapComponent.optionBuilder.googlizeAllInputs(INPUTS$2, this);\n        this.infoWindow = new google.maps.InfoWindow(this.objectOptions);\n        this.infoWindow['mapObjectName'] = 'InfoWindow';\n        // register infoWindow ids to NguiMap, so that it can be opened by id\n        if (this.elementRef.nativeElement.id) {\n            this.nguiMapComponent.infoWindows[this.elementRef.nativeElement.id] = this;\n        }\n        else {\n            console.error('An InfoWindow must have an id. e.g. id=\"detail\"');\n        }\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(OUTPUTS$2, this, 'infoWindow');\n        // update object when input changes\n        this.inputChanges$.pipe(debounceTime(1000), tap((changes) => this.nguiMap.updateGoogleObject(this.infoWindow, changes))).subscribe();\n        this.nguiMapComponent.addToMapObjectGroup('InfoWindow', this.infoWindow);\n        this.initialized$.emit(this.infoWindow);\n    }\n    /**\n     * @param {?} anchor\n     * @return {?}\n     */\n    open(anchor) {\n        // set content and open it\n        this.infoWindow.setContent(this.template.element.nativeElement);\n        this.infoWindow.open(this.nguiMapComponent.map, anchor);\n    }\n    /**\n     * @return {?}\n     */\n    close() {\n        // check if infoWindow exists, and closes it\n        if (this.infoWindow)\n            this.infoWindow.close();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.inputChanges$.complete();\n        if (this.infoWindow) {\n            this.nguiMap.clearObjectEvents(OUTPUTS$2, this, 'infoWindow');\n            delete this.infoWindow;\n        }\n    }\n}\nInfoWindow.ɵfac = function InfoWindow_Factory(t) { return new (t || InfoWindow)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NguiMap), ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nInfoWindow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: InfoWindow, selectors: [[\"info-window\"]], viewQuery: function InfoWindow_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, true, ViewContainerRef);\n    } if (rf & 2) {\n        var _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);\n    } }, inputs: { content: \"content\", disableAutoPan: \"disableAutoPan\", maxWidth: \"maxWidth\", pixelOffset: \"pixelOffset\", position: \"position\", zIndex: \"zIndex\", options: \"options\" }, outputs: { closeclick: \"closeclick\", content_changed: \"content_changed\", domready: \"domready\", position_changed: \"position_changed\", zindex_changed: \"zindex_changed\", initialized$: \"initialized$\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 0, consts: [[\"template\", \"\"]], template: function InfoWindow_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n    } }, encapsulation: 2 });\n/** @nocollapse */\nInfoWindow.ctorParameters = () => [\n    { type: ElementRef, },\n    { type: NguiMap, },\n    { type: NguiMapComponent, },\n];\nInfoWindow.propDecorators = {\n    \"initialized$\": [{ type: Output },],\n    \"template\": [{ type: ViewChild, args: ['template', { read: ViewContainerRef },] },],\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InfoWindow, [{\n        type: Component,\n        args: [{\n                selector: 'ngui-map > info-window',\n                inputs: INPUTS$2,\n                outputs: OUTPUTS$2,\n                template: `<div #template><ng-content></ng-content></div>`\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NguiMap }, { type: NguiMapComponent }]; }, { initialized$: [{\n            type: Output\n        }], template: [{\n            type: ViewChild,\n            args: ['template', { read: ViewContainerRef }]\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$3 = [\n    'position'\n];\n// to avoid DOM event conflicts map_*\nconst OUTPUTS$3 = [\n    'animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged',\n    'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick',\n    'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged',\n    'map_click', 'map_mouseover', 'map_mouseout', 'map_mouseup', 'map_mousedown', 'map_drag', 'map_dragend'\n];\n/**\n * Wrapper to a create extend OverlayView at runtime, only after google maps is loaded.\n * Otherwise throws a google is unknown error.\n * @param {?} htmlEl\n * @param {?} position\n * @return {?}\n */\nfunction getCustomMarkerOverlayView(htmlEl, position) {\n    class CustomMarkerOverlayView extends google.maps.OverlayView {\n        /**\n         * @param {?} htmlEl\n         * @param {?} position\n         */\n        constructor(htmlEl, position) {\n            super();\n            this.visible = true;\n            this.setPosition = (position) => {\n                this.htmlEl.style.visibility = 'hidden';\n                if (position.constructor.name === 'Array') {\n                    this.position = new google.maps.LatLng(position[0], position[1]);\n                }\n                else if (typeof position === 'string') {\n                    let /** @type {?} */ geocoder = new google.maps.Geocoder();\n                    geocoder.geocode({ address: position }, (results, status) => {\n                        if (status === google.maps.GeocoderStatus.OK) {\n                            this.setPosition(results[0].geometry.location);\n                        }\n                        else {\n                        }\n                    });\n                }\n                else if (position && typeof position.lng === 'function') {\n                    this.position = position;\n                }\n                if (this.getProjection() && typeof this.position.lng === 'function') {\n                    let /** @type {?} */ positionOnMap = () => {\n                        let /** @type {?} */ projection = this.getProjection();\n                        if (!projection) {\n                            return;\n                        }\n                        let /** @type {?} */ posPixel = projection.fromLatLngToDivPixel(this.position);\n                        let /** @type {?} */ x = Math.round(posPixel.x - (this.htmlEl.offsetWidth / 2));\n                        let /** @type {?} */ y = Math.round(posPixel.y - this.htmlEl.offsetHeight / 2);\n                        this.htmlEl.style.left = x + 'px';\n                        this.htmlEl.style.top = y + 'px';\n                        this.htmlEl.style.visibility = 'visible';\n                    };\n                    if (this.htmlEl.offsetWidth && this.htmlEl.offsetHeight) {\n                        positionOnMap();\n                    }\n                    else {\n                        setTimeout(() => positionOnMap());\n                    }\n                }\n            };\n            this.htmlEl = htmlEl;\n            this.position = position;\n        }\n        /**\n         * @return {?}\n         */\n        onAdd() {\n            this.getPanes().overlayMouseTarget.appendChild(this.htmlEl);\n            // required for correct display inside google maps container\n            this.htmlEl.style.position = 'absolute';\n        }\n        /**\n         * @return {?}\n         */\n        draw() {\n            this.setPosition(this.position);\n            this.setZIndex(this.zIndex);\n            this.setVisible(this.visible);\n        }\n        /**\n         * @return {?}\n         */\n        onRemove() {\n            //\n        }\n        /**\n         * @return {?}\n         */\n        getPosition() {\n            return this.position;\n        }\n        /**\n         * @param {?} zIndex\n         * @return {?}\n         */\n        setZIndex(zIndex) {\n            zIndex && (this.zIndex = zIndex); /* jshint ignore:line */\n            this.htmlEl.style.zIndex = this.zIndex;\n        }\n        /**\n         * @param {?} visible\n         * @return {?}\n         */\n        setVisible(visible) {\n            this.htmlEl.style.display = visible ? 'inline-block' : 'none';\n            this.visible = visible;\n        }\n    }\n    return new CustomMarkerOverlayView(htmlEl, position);\n}\nclass CustomMarker {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     */\n    constructor(nguiMapComponent, elementRef, nguiMap) {\n        this.nguiMapComponent = nguiMapComponent;\n        this.elementRef = elementRef;\n        this.nguiMap = nguiMap;\n        this.initialized$ = new EventEmitter();\n        this.inputChanges$ = new Subject();\n        this.elementRef.nativeElement.style.display = 'none';\n        OUTPUTS$3.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            // map is ready already\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.inputChanges$.complete();\n        this.nguiMapComponent.removeFromMapObjectGroup('CustomMarker', this.mapObject);\n        if (this.mapObject) {\n            this.nguiMap.clearObjectEvents(OUTPUTS$3, this, 'mapObject');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.el = this.elementRef.nativeElement;\n        this.mapObject = getCustomMarkerOverlayView(this.el, this['position']);\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(OUTPUTS$3, this, 'mapObject');\n        // update object when input changes\n        this.inputChanges$.pipe(debounceTime(1000), tap((changes) => this.nguiMap.updateGoogleObject(this.mapObject, changes))).subscribe();\n        this.nguiMapComponent.addToMapObjectGroup('CustomMarker', this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n}\nCustomMarker.ɵfac = function CustomMarker_Factory(t) { return new (t || CustomMarker)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NguiMap)); };\nCustomMarker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CustomMarker, selectors: [[\"custom-marker\"]], inputs: { position: \"position\" }, outputs: { animationChanged: \"animationChanged\", click: \"click\", clickableChanged: \"clickableChanged\", cursorChanged: \"cursorChanged\", dblclick: \"dblclick\", drag: \"drag\", dragend: \"dragend\", draggableChanged: \"draggableChanged\", dragstart: \"dragstart\", flatChanged: \"flatChanged\", iconChanged: \"iconChanged\", mousedown: \"mousedown\", mouseout: \"mouseout\", mouseover: \"mouseover\", mouseup: \"mouseup\", positionChanged: \"positionChanged\", rightclick: \"rightclick\", shapeChanged: \"shapeChanged\", titleChanged: \"titleChanged\", visibleChanged: \"visibleChanged\", zindexChanged: \"zindexChanged\", map_click: \"map_click\", map_mouseover: \"map_mouseover\", map_mouseout: \"map_mouseout\", map_mouseup: \"map_mouseup\", map_mousedown: \"map_mousedown\", map_drag: \"map_drag\", map_dragend: \"map_dragend\", initialized$: \"initialized$\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function CustomMarker_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n    } }, encapsulation: 2 });\n/** @nocollapse */\nCustomMarker.ctorParameters = () => [\n    { type: NguiMapComponent, },\n    { type: ElementRef, },\n    { type: NguiMap, },\n];\nCustomMarker.propDecorators = {\n    \"initialized$\": [{ type: Output },],\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CustomMarker, [{\n        type: Component,\n        args: [{\n                selector: 'ngui-map > custom-marker',\n                inputs: INPUTS$3,\n                outputs: OUTPUTS$3,\n                template: `\r\n    <ng-content></ng-content>\r\n  `\n            }]\n    }], function () { return [{ type: NguiMapComponent }, { type: ɵngcc0.ElementRef }, { type: NguiMap }]; }, { initialized$: [{\n            type: Output\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$4 = [\n    'center', 'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'map', 'radius',\n    'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options',\n    'geoFallbackCenter'\n];\nconst OUTPUTS$4 = [\n    'centerChanged', 'click', 'dblclick', 'drag', 'dragend', 'dragstart',\n    'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'radiusChanged', 'rightclick',\n];\nclass Circle extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Circle', INPUTS$4, OUTPUTS$4);\n        this.nguiMapComp = nguiMapComp;\n        this.objectOptions = /** @type {?} */ ({});\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        super.initialize();\n        this.setCenter();\n    }\n    /**\n     * @return {?}\n     */\n    setCenter() {\n        if (!this['center']) {\n            this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(center => {\n                let /** @type {?} */ latLng = new google.maps.LatLng(center.coords.latitude, center.coords.longitude);\n                this.mapObject.setCenter(latLng);\n            }, error => {\n                console.error('ngui-map, error in finding the current position');\n                this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n        else if (typeof this['center'] === 'string') {\n            this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({ address: this['center'] }).subscribe(results => {\n                this.mapObject.setCenter(results[0].geometry.location);\n            }, error => {\n                console.error('ngui-map, error in finding location from', this['center']);\n                this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n    }\n}\nCircle.ɵfac = function Circle_Factory(t) { return new (t || Circle)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nCircle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Circle, selectors: [[\"circle\"], [\"map-circle\"]], inputs: { center: \"center\", clickable: \"clickable\", draggable: \"draggable\", editable: \"editable\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", map: \"map\", radius: \"radius\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokePosition: \"strokePosition\", strokeWeight: \"strokeWeight\", visible: \"visible\", zIndex: \"zIndex\", options: \"options\", geoFallbackCenter: \"geoFallbackCenter\" }, outputs: { centerChanged: \"centerChanged\", click: \"click\", dblclick: \"dblclick\", drag: \"drag\", dragend: \"dragend\", dragstart: \"dragstart\", mousedown: \"mousedown\", mousemove: \"mousemove\", mouseout: \"mouseout\", mouseover: \"mouseover\", mouseup: \"mouseup\", radiusChanged: \"radiusChanged\", rightclick: \"rightclick\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nCircle.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Circle, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map>circle, ngui-map>map-circle',\n                inputs: INPUTS$4,\n                outputs: OUTPUTS$4\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$5 = ['controlPosition', 'controls', 'drawingMode', 'featureFactory', 'style', 'geoJson', 'geoJsonUrl'];\nconst OUTPUTS$5 = [\n    'addfeature', 'click', 'dblclick', 'mousedown', 'mouseout', 'mouseover',\n    'mouseup', 'removefeature', 'removeproperty', 'rightclick', 'setgeometry', 'setproperty'\n];\nclass DataLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     */\n    constructor(nguiMapComponent) {\n        super(nguiMapComponent, 'Data', INPUTS$5, OUTPUTS$5);\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        if (this['geoJson']) {\n            // addGeoJson from an object\n            this.nguiMapComponent.map.data.addGeoJson(this['geoJson']);\n        }\n        else if (this['geoJsonUrl']) {\n            // loadGeoJson from a URL\n            this.nguiMapComponent.map.data.loadGeoJson(this['geoJsonUrl']);\n        }\n        else {\n            this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n            this.nguiMapComponent.map.data.add(this.objectOptions);\n        }\n        // unlike others, data belongs to map. e.g., map.data.loadGeoJson(), map.data.add()\n        this.mapObject = this.nguiMapComponent.map.data;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n}\nDataLayer.ɵfac = function DataLayer_Factory(t) { return new (t || DataLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nDataLayer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DataLayer, selectors: [[\"data-layer\"]], inputs: { controlPosition: \"controlPosition\", controls: \"controls\", drawingMode: \"drawingMode\", featureFactory: \"featureFactory\", style: \"style\", geoJson: \"geoJson\", geoJsonUrl: \"geoJsonUrl\" }, outputs: { addfeature: \"addfeature\", click: \"click\", dblclick: \"dblclick\", mousedown: \"mousedown\", mouseout: \"mouseout\", mouseover: \"mouseover\", mouseup: \"mouseup\", removefeature: \"removefeature\", removeproperty: \"removeproperty\", rightclick: \"rightclick\", setgeometry: \"setgeometry\", setproperty: \"setproperty\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nDataLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DataLayer, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > data-layer',\n                inputs: INPUTS$5,\n                outputs: OUTPUTS$5\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$6 = [\n    'directions', 'draggable', 'hideRouteList', 'infoWindow', 'panel', 'markerOptions',\n    'polylineOptions', 'preserveViewport', 'routeIndex', 'suppressBicyclingLayer',\n    'suppressInfoWindows', 'suppressMarkers', 'suppressPolylines'\n];\nconst OUTPUTS$6 = ['directions_changed'];\nclass DirectionsRenderer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} geolocation\n     */\n    constructor(nguiMapComponent, geolocation) {\n        super(nguiMapComponent, 'DirectionsRenderer', INPUTS$6, OUTPUTS$6);\n        this.geolocation = geolocation;\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        if (typeof this.objectOptions['panel'] === 'string') {\n            // find a Node for panel\n            this.objectOptions['panel'] = document.querySelector(this.objectOptions['panel']);\n        }\n        this.directionsService = new google.maps.DirectionsService();\n        this.directionsRenderer = new google.maps.DirectionsRenderer(this.objectOptions);\n        this.directionsRenderer.setMap(this.nguiMapComponent.map);\n        // set google events listeners and emidirectionsRenderer to this outputs listeners\n        this.showDirections(this.directionsRequest);\n        this.nguiMap.setObjectEvents(this.outputs, this, 'directionsRenderer');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.directionsRenderer);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        let /** @type {?} */ newOptions = {};\n        for (let /** @type {?} */ key in changes) {\n            if (this.inputs.indexOf(key) !== -1) {\n                newOptions[key] = this.optionBuilder.googlize(changes[key].currentValue);\n            }\n        }\n        if (changes['directionsRequest'] && this.directionsRenderer) {\n            this.directionsService && this.showDirections(this.directionsRequest);\n        }\n    }\n    /**\n     * @param {?} directionsRequest\n     * @return {?}\n     */\n    showDirections(directionsRequest) {\n        this.directionsService.route(directionsRequest, (response, status) => {\n            // in some-case the callback is called during destroy component,\n            // we should make sure directionsRenderer is still defined (cancelling `route` callback is not possible).\n            if (!this.directionsRenderer) {\n                return;\n            }\n            if (status === google.maps.DirectionsStatus.OK) {\n                this.directionsRenderer.setDirections(response);\n            }\n            else {\n                console.error('Directions request failed due to ' + status);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this.nguiMap.clearObjectEvents(this.outputs, this, 'directionsRenderer');\n    }\n}\nDirectionsRenderer.ɵfac = function DirectionsRenderer_Factory(t) { return new (t || DirectionsRenderer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent), ɵngcc0.ɵɵdirectiveInject(NavigatorGeolocation)); };\nDirectionsRenderer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DirectionsRenderer, selectors: [[\"directions-renderer\"]], inputs: { directions: \"directions\", draggable: \"draggable\", hideRouteList: \"hideRouteList\", infoWindow: \"infoWindow\", panel: \"panel\", markerOptions: \"markerOptions\", polylineOptions: \"polylineOptions\", preserveViewport: \"preserveViewport\", routeIndex: \"routeIndex\", suppressBicyclingLayer: \"suppressBicyclingLayer\", suppressInfoWindows: \"suppressInfoWindows\", suppressMarkers: \"suppressMarkers\", suppressPolylines: \"suppressPolylines\", directionsRequest: [\"directions-request\", \"directionsRequest\"] }, outputs: { directions_changed: \"directions_changed\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\n/** @nocollapse */\nDirectionsRenderer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n    { type: NavigatorGeolocation, },\n];\nDirectionsRenderer.propDecorators = {\n    \"directionsRequest\": [{ type: Input, args: ['directions-request',] },],\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DirectionsRenderer, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > directions-renderer',\n                inputs: INPUTS$6,\n                outputs: OUTPUTS$6\n            }]\n    }], function () { return [{ type: NguiMapComponent }, { type: NavigatorGeolocation }]; }, { directionsRequest: [{\n            type: Input,\n            args: ['directions-request']\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$7 = [\n    'options',\n    'circleOptions', 'drawingControl', 'drawingControlOptions', 'drawingMode',\n    'map', 'markerOptions', 'polygonOptions', 'polylineOptions', 'rectangleOptions'\n];\nconst OUTPUTS$7 = [\n    'circlecomplete', 'markercomplete', 'overlaycomplete',\n    'polygoncomplete', 'polylinecomplete', 'rectanglecomplete'\n];\nclass DrawingManager extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'DrawingManager', INPUTS$7, OUTPUTS$7);\n        this.libraryName = 'drawing';\n    }\n}\nDrawingManager.ɵfac = function DrawingManager_Factory(t) { return new (t || DrawingManager)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nDrawingManager.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawingManager, selectors: [[\"drawing-manager\"]], inputs: { options: \"options\", circleOptions: \"circleOptions\", drawingControl: \"drawingControl\", drawingControlOptions: \"drawingControlOptions\", drawingMode: \"drawingMode\", map: \"map\", markerOptions: \"markerOptions\", polygonOptions: \"polygonOptions\", polylineOptions: \"polylineOptions\", rectangleOptions: \"rectangleOptions\" }, outputs: { circlecomplete: \"circlecomplete\", markercomplete: \"markercomplete\", overlaycomplete: \"overlaycomplete\", polygoncomplete: \"polygoncomplete\", polylinecomplete: \"polylinecomplete\", rectanglecomplete: \"rectanglecomplete\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nDrawingManager.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawingManager, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > drawing-manager',\n                inputs: INPUTS$7,\n                outputs: OUTPUTS$7\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$8 = ['url', 'bounds', 'clickable', 'opacity'];\nconst OUTPUTS$8 = ['click', 'dblclick'];\nclass GroundOverlay extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'GroundOverlay', INPUTS$8, OUTPUTS$8);\n        this.objectOptions = /** @type {?} */ ({});\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        // url, bounds are not the options of GroundOverlay\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(['clickable', 'opacity'], this);\n        // noinspection TypeScriptUnresolvedFunction\n        this.mapObject = new google.maps.GroundOverlay(this['url'], this['bounds'], this.objectOptions);\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n}\nGroundOverlay.ɵfac = function GroundOverlay_Factory(t) { return new (t || GroundOverlay)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nGroundOverlay.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroundOverlay, selectors: [[\"ground-overlay\"]], inputs: { url: \"url\", bounds: \"bounds\", clickable: \"clickable\", opacity: \"opacity\" }, outputs: { click: \"click\", dblclick: \"dblclick\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nGroundOverlay.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroundOverlay, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > ground-overlay',\n                inputs: INPUTS$8,\n                outputs: OUTPUTS$8\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$9 = ['data', 'dissipating', 'gradient', 'maxIntensity', 'opacity', 'radius', 'options'];\nconst OUTPUTS$9 = [];\nclass HeatmapLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'HeatmapLayer', INPUTS$9, OUTPUTS$9);\n        this.libraryName = 'visualization';\n    }\n}\nHeatmapLayer.ɵfac = function HeatmapLayer_Factory(t) { return new (t || HeatmapLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nHeatmapLayer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HeatmapLayer, selectors: [[\"heatmap-layer\"]], inputs: { data: \"data\", dissipating: \"dissipating\", gradient: \"gradient\", maxIntensity: \"maxIntensity\", opacity: \"opacity\", radius: \"radius\", options: \"options\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nHeatmapLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatmapLayer, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > heatmap-layer',\n                inputs: INPUTS$9,\n                outputs: OUTPUTS$9\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$10 = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex', 'options'];\nconst OUTPUTS$10 = ['click', 'defaultviewport_changed', 'status_changed'];\nclass KmlLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'KmlLayer', INPUTS$10, OUTPUTS$10);\n    }\n}\nKmlLayer.ɵfac = function KmlLayer_Factory(t) { return new (t || KmlLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nKmlLayer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: KmlLayer, selectors: [[\"kml-layer\"]], inputs: { clickable: \"clickable\", preserveViewport: \"preserveViewport\", screenOverlays: \"screenOverlays\", suppressInfoWindows: \"suppressInfoWindows\", url: \"url\", zIndex: \"zIndex\", options: \"options\" }, outputs: { click: \"click\", defaultviewport_changed: \"defaultviewport_changed\", status_changed: \"status_changed\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nKmlLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(KmlLayer, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > kml-layer',\n                inputs: INPUTS$10,\n                outputs: OUTPUTS$10\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$11 = [\n    'anchorPoint', 'animation', 'clickable', 'cursor', 'draggable', 'icon', 'label', 'opacity',\n    'optimized', 'place', 'position', 'shape', 'title', 'visible', 'zIndex', 'options',\n    'geoFallbackPosition'\n];\nconst OUTPUTS$11 = [\n    'animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged',\n    'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick',\n    'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged'\n];\nclass Marker extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Marker', INPUTS$11, OUTPUTS$11);\n        this.nguiMapComp = nguiMapComp;\n        this.objectOptions = /** @type {?} */ ({});\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            // map is ready already\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        super.initialize();\n        this.setPosition();\n    }\n    /**\n     * @return {?}\n     */\n    setPosition() {\n        if (!this['position']) {\n            this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(position => {\n                let /** @type {?} */ latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n                this.mapObject.setPosition(latLng);\n            }, error => {\n                console.error('ngui-map, error finding the current location');\n                this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n        else if (typeof this['position'] === 'string') {\n            this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({ address: this['position'] }).subscribe(results => {\n                this.mapObject.setPosition(results[0].geometry.location);\n            }, error => {\n                console.error('ngui-map, error finding the location from', this['position']);\n                this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n    }\n}\nMarker.ɵfac = function Marker_Factory(t) { return new (t || Marker)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nMarker.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Marker, selectors: [[\"marker\"]], inputs: { anchorPoint: \"anchorPoint\", animation: \"animation\", clickable: \"clickable\", cursor: \"cursor\", draggable: \"draggable\", icon: \"icon\", label: \"label\", opacity: \"opacity\", optimized: \"optimized\", place: \"place\", position: \"position\", shape: \"shape\", title: \"title\", visible: \"visible\", zIndex: \"zIndex\", options: \"options\", geoFallbackPosition: \"geoFallbackPosition\" }, outputs: { animationChanged: \"animationChanged\", click: \"click\", clickableChanged: \"clickableChanged\", cursorChanged: \"cursorChanged\", dblclick: \"dblclick\", drag: \"drag\", dragend: \"dragend\", draggableChanged: \"draggableChanged\", dragstart: \"dragstart\", flatChanged: \"flatChanged\", iconChanged: \"iconChanged\", mousedown: \"mousedown\", mouseout: \"mouseout\", mouseover: \"mouseover\", mouseup: \"mouseup\", positionChanged: \"positionChanged\", rightclick: \"rightclick\", shapeChanged: \"shapeChanged\", titleChanged: \"titleChanged\", visibleChanged: \"visibleChanged\", zindexChanged: \"zindexChanged\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nMarker.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Marker, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > marker',\n                inputs: INPUTS$11,\n                outputs: OUTPUTS$11\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass PlacesAutoComplete {\n    /**\n     * @param {?} optionBuilder\n     * @param {?} elementRef\n     * @param {?} apiLoader\n     */\n    constructor(optionBuilder, elementRef, apiLoader) {\n        this.optionBuilder = optionBuilder;\n        this.elementRef = elementRef;\n        this.apiLoader = apiLoader;\n        this.place_changed = new EventEmitter();\n        this.initialized$ = new EventEmitter();\n        // only called when map is ready\n        this.initialize = () => {\n            this.objectOptions =\n                this.optionBuilder.googlizeAllInputs(['bounds', 'componentRestrictions', 'types'], this);\n            if (!google.maps.places) {\n                throw missingLibraryError('PlacesAutoComplete', 'places');\n            }\n            this.autocomplete = new google.maps.places.Autocomplete(this.elementRef.nativeElement, this.objectOptions);\n            this.autocomplete.addListener('place_changed', place => {\n                this.place_changed.emit(this.autocomplete.getPlace());\n            });\n            this.initialized$.emit(this.autocomplete);\n        };\n        apiLoader.load();\n        apiLoader.api$\n            .pipe(first())\n            .subscribe(() => this.initialize());\n    }\n}\nPlacesAutoComplete.ɵfac = function PlacesAutoComplete_Factory(t) { return new (t || PlacesAutoComplete)(ɵngcc0.ɵɵdirectiveInject(OptionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgMapApiLoader)); };\nPlacesAutoComplete.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PlacesAutoComplete, selectors: [[\"\", \"places-auto-complete\", \"\"]], inputs: { bounds: \"bounds\", componentRestrictions: \"componentRestrictions\", types: \"types\" }, outputs: { place_changed: \"place_changed\", initialized$: \"initialized$\" } });\n/** @nocollapse */\nPlacesAutoComplete.ctorParameters = () => [\n    { type: OptionBuilder, },\n    { type: ElementRef, },\n    { type: NgMapApiLoader, },\n];\nPlacesAutoComplete.propDecorators = {\n    \"bounds\": [{ type: Input },],\n    \"componentRestrictions\": [{ type: Input },],\n    \"types\": [{ type: Input },],\n    \"place_changed\": [{ type: Output, args: ['place_changed',] },],\n    \"initialized$\": [{ type: Output },],\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PlacesAutoComplete, [{\n        type: Directive,\n        args: [{\n                selector: '[places-auto-complete]'\n            }]\n    }], function () { return [{ type: OptionBuilder }, { type: ɵngcc0.ElementRef }, { type: NgMapApiLoader }]; }, { place_changed: [{\n            type: Output,\n            args: ['place_changed']\n        }], initialized$: [{\n            type: Output\n        }], bounds: [{\n            type: Input\n        }], componentRestrictions: [{\n            type: Input\n        }], types: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$12 = [\n    'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'paths',\n    'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options',\n];\nconst OUTPUTS$12 = [\n    'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown',\n    'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick',\n];\nclass Polygon extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Polygon', INPUTS$12, OUTPUTS$12);\n    }\n}\nPolygon.ɵfac = function Polygon_Factory(t) { return new (t || Polygon)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nPolygon.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Polygon, selectors: [[\"polygon\"], [\"map-polygon\"]], inputs: { clickable: \"clickable\", draggable: \"draggable\", editable: \"editable\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", geodesic: \"geodesic\", paths: \"paths\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokePosition: \"strokePosition\", strokeWeight: \"strokeWeight\", visible: \"visible\", zIndex: \"zIndex\", options: \"options\" }, outputs: { click: \"click\", dblclick: \"dblclick\", drag: \"drag\", dragend: \"dragend\", dragstart: \"dragstart\", mousedown: \"mousedown\", mousemove: \"mousemove\", mouseout: \"mouseout\", mouseover: \"mouseover\", mouseup: \"mouseup\", rightclick: \"rightclick\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nPolygon.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Polygon, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map>polygon, ngui-map>map-polygon',\n                inputs: INPUTS$12,\n                outputs: OUTPUTS$12\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$13 = [\n    'clickable', 'draggable', 'editable', 'geodesic', 'icons', 'path', 'strokeColor',\n    'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'options'\n];\nconst OUTPUTS$13 = [\n    'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown',\n    'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'\n];\nclass Polyline extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Polyline', INPUTS$13, OUTPUTS$13);\n    }\n}\nPolyline.ɵfac = function Polyline_Factory(t) { return new (t || Polyline)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nPolyline.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Polyline, selectors: [[\"polyline\"]], inputs: { clickable: \"clickable\", draggable: \"draggable\", editable: \"editable\", geodesic: \"geodesic\", icons: \"icons\", path: \"path\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokeWeight: \"strokeWeight\", visible: \"visible\", zIndex: \"zIndex\", options: \"options\" }, outputs: { click: \"click\", dblclick: \"dblclick\", drag: \"drag\", dragend: \"dragend\", dragstart: \"dragstart\", mousedown: \"mousedown\", mousemove: \"mousemove\", mouseout: \"mouseout\", mouseover: \"mouseover\", mouseup: \"mouseup\", rightclick: \"rightclick\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nPolyline.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Polyline, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > polyline',\n                inputs: INPUTS$13,\n                outputs: OUTPUTS$13\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$14 = [\n    'selector', 'options',\n    'addressControl', 'addressControlOptions', 'clickToGo', 'disableDefaultUI', 'disableDoubleClickZoom',\n    'enableCloseButton', 'fullscreenControl', 'fullscreenControlOptions', 'imageDateControl', 'linksControl',\n    'motionTracking', 'motionTrackingControl', 'panControl', 'panControlOptions', 'pano',\n    'position', 'pov', 'scrollwheel', 'showRoadLabels', 'visible', 'zoomControl', 'zoomControlOptions'\n];\nconst OUTPUTS$14 = [\n    'closeclick', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'status_changed',\n    'visible_changed', 'zoom_changed'\n];\nclass StreetViewPanorama extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'StreetViewPanorama', INPUTS$14, OUTPUTS$14);\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        let /** @type {?} */ element;\n        if (this.objectOptions.selector) {\n            // noinspection TypeScriptValidateTypes\n            element = document.querySelector(this['selector']);\n            delete this.objectOptions.selector;\n        }\n        else {\n            element = this.nguiMapComponent.el;\n        }\n        // will be set after geocoded\n        typeof this.objectOptions.position === 'string' && (delete this.objectOptions.position);\n        this.mapObject = new google.maps[this.mapObjectName](element, this.objectOptions);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        this.mapObject['nguiMapComponent'] = this.nguiMapComponent;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.nguiMapComponent.el) {\n            this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n        }\n    }\n}\nStreetViewPanorama.ɵfac = function StreetViewPanorama_Factory(t) { return new (t || StreetViewPanorama)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nStreetViewPanorama.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StreetViewPanorama, selectors: [[\"street-view-panorama\"]], inputs: { selector: \"selector\", options: \"options\", addressControl: \"addressControl\", addressControlOptions: \"addressControlOptions\", clickToGo: \"clickToGo\", disableDefaultUI: \"disableDefaultUI\", disableDoubleClickZoom: \"disableDoubleClickZoom\", enableCloseButton: \"enableCloseButton\", fullscreenControl: \"fullscreenControl\", fullscreenControlOptions: \"fullscreenControlOptions\", imageDateControl: \"imageDateControl\", linksControl: \"linksControl\", motionTracking: \"motionTracking\", motionTrackingControl: \"motionTrackingControl\", panControl: \"panControl\", panControlOptions: \"panControlOptions\", pano: \"pano\", position: \"position\", pov: \"pov\", scrollwheel: \"scrollwheel\", showRoadLabels: \"showRoadLabels\", visible: \"visible\", zoomControl: \"zoomControl\", zoomControlOptions: \"zoomControlOptions\" }, outputs: { closeclick: \"closeclick\", pano_changed: \"pano_changed\", position_changed: \"position_changed\", pov_changed: \"pov_changed\", resize: \"resize\", status_changed: \"status_changed\", visible_changed: \"visible_changed\", zoom_changed: \"zoom_changed\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nStreetViewPanorama.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StreetViewPanorama, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > street-view-panorama',\n                inputs: INPUTS$14,\n                outputs: OUTPUTS$14\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$15 = ['autoRefresh', 'options'];\nconst OUTPUTS$15 = [];\nclass TrafficLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'TrafficLayer', INPUTS$15, OUTPUTS$15);\n    }\n}\nTrafficLayer.ɵfac = function TrafficLayer_Factory(t) { return new (t || TrafficLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nTrafficLayer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TrafficLayer, selectors: [[\"traffic-layer\"]], inputs: { autoRefresh: \"autoRefresh\", options: \"options\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nTrafficLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TrafficLayer, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > traffic-layer',\n                inputs: INPUTS$15,\n                outputs: OUTPUTS$15\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst INPUTS$16 = [];\nconst OUTPUTS$16 = [];\nclass TransitLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'TransitLayer', INPUTS$16, OUTPUTS$16);\n    }\n}\nTransitLayer.ɵfac = function TransitLayer_Factory(t) { return new (t || TransitLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent)); };\nTransitLayer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TransitLayer, selectors: [[\"transit-layer\"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nTransitLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TransitLayer, [{\n        type: Directive,\n        args: [{\n                selector: 'ngui-map > transit-layer',\n                inputs: INPUTS$16,\n                outputs: OUTPUTS$16\n            }]\n    }], function () { return [{ type: NguiMapComponent }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst COMPONENTS_DIRECTIVES = [\n    NguiMapComponent, InfoWindow,\n    Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay,\n    TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer,\n    StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer,\n    DrawingManager,\n];\nclass NguiMapModule {\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    static forRoot(config = {}) {\n        return {\n            ngModule: NguiMapModule,\n            providers: [\n                { provide: NG_MAP_CONFIG_TOKEN, useValue: config }\n            ],\n        };\n    }\n}\nNguiMapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NguiMapModule });\nNguiMapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NguiMapModule_Factory(t) { return new (t || NguiMapModule)(); }, providers: [\n        GeoCoder,\n        NavigatorGeolocation,\n        NguiMap,\n        OptionBuilder,\n        { provide: NgMapApiLoader, useClass: NgMapAsyncCallbackApiLoader },\n    ], imports: [[CommonModule]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NguiMapModule, { declarations: function () { return [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager]; } }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NguiMapModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule],\n                declarations: COMPONENTS_DIRECTIVES,\n                exports: [COMPONENTS_DIRECTIVES],\n                providers: [\n                    GeoCoder,\n                    NavigatorGeolocation,\n                    NguiMap,\n                    OptionBuilder,\n                    { provide: NgMapApiLoader, useClass: NgMapAsyncCallbackApiLoader },\n                ]\n            }]\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BicyclingLayer, NavigatorGeolocation, OptionBuilder, NG_MAP_CONFIG_TOKEN, NgMapApiLoader, NgMapAsyncApiLoader, NgMapAsyncCallbackApiLoader, NguiMapComponent, InfoWindow, CustomMarker, Circle, DataLayer, DirectionsRenderer, DrawingManager, GeoCoder, GroundOverlay, HeatmapLayer, KmlLayer, Marker, NguiMap, PlacesAutoComplete, Polygon, Polyline, StreetViewPanorama, TrafficLayer, TransitLayer, NguiMapModule, BaseMapDirective as ɵa };\n\n//# sourceMappingURL=ngui-map.js.map","import {Component, OnInit } from '@angular/core';\n\ndeclare var google:any;\n\n@Component({\n    moduleId: module.id,\n    selector: 'fullscreen-map-cmp',\n    templateUrl: 'fullscreenmap.component.html'\n})\n\nexport class FullScreenMapsComponent implements OnInit{\n    ngOnInit(){\n\t}\n}\n","import { Component, OnInit } from '@angular/core';\n\ndeclare var $: any;\n\n@Component({\n    moduleId: module.id,\n    selector: 'vector-maps-cmp',\n    templateUrl: './vectormaps.component.html'\n})\n\nexport class VectorMapsComponent implements OnInit{\n    ngOnInit(){\n        var mapData = {\n            \"AU\": 760,\n            \"BR\": 550,\n            \"CA\": 120,\n            \"DE\": 1300,\n            \"FR\": 540,\n            \"GB\": 690,\n            \"GE\": 200,\n            \"IN\": 200,\n            \"RO\": 600,\n            \"RU\": 300,\n            \"US\": 2920,\n        };\n\n        $('#worldMap').vectorMap({\n            map: 'world_mill_en',\n            backgroundColor: \"transparent\",\n            zoomOnScroll: false,\n            regionStyle: {\n                initial: {\n                    fill: '#e4e4e4',\n                    \"fill-opacity\": 0.9,\n                    stroke: 'none',\n                    \"stroke-width\": 0,\n                    \"stroke-opacity\": 0\n                }\n            },\n\n            series: {\n                regions: [{\n                    values: mapData,\n                    scale: [\"#AAAAAA\",\"#444444\"],\n                    normalizeFunction: 'polynomial'\n                }]\n            },\n        });\n    }\n}\n","export default \"<div class=\\\"main-content\\\">\\n  <div class=\\\"row\\\">\\n    <div class=\\\"col-md-12\\\">\\n      <div class=\\\"card \\\">\\n        <div class=\\\"card-header\\\">\\n            <h4 class=\\\"card-title\\\">Satellite Map</h4>\\n        </div>\\n        <div class=\\\"card-body \\\">\\n          <ngui-map zoom=\\\"3\\\" center=\\\"40.748817,-73.985428\\\"  mapTypeId=\\\"satellite\\\" >\\n              <marker [position]=\\\"[40.748817,-73.985428]\\\"></marker>\\n          </ngui-map>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\\\"col-md-12\\\">\\n      <div class=\\\"card \\\">\\n        <div class=\\\"card-header \\\">\\n          <h4 class='card-title'>Regular Map</h4>\\n        </div>\\n        <div class=\\\"card-body \\\">\\n          <ngui-map zoom=\\\"13\\\" center=\\\"40.748817,-73.985428\\\" >\\n              <marker [position]=\\\"[40.748817,-73.985428]\\\"></marker>\\n          </ngui-map>\\n        </div>\\n      </div>\\n    </div>\\n  </div>\\n</div>\\n\";","import { Routes } from '@angular/router';\n\nimport { FullScreenMapsComponent } from './fullscreenmap/fullscreenmap.component';\nimport { GoogleMapsComponent } from './googlemaps/googlemaps.component';\nimport { VectorMapsComponent } from './vectormaps/vectormaps.component';\n\nexport const MapsRoutes: Routes = [{\n        path: '',\n        children: [{\n            path: 'fullscreen',\n            component: FullScreenMapsComponent\n        }]\n    },{\n        path: '',\n        children: [{\n            path: 'google',\n            component: GoogleMapsComponent\n        }]\n    },{\n        path: '',\n        children: [{\n            path: 'vector',\n            component: VectorMapsComponent\n        }]\n    }\n];\n","export default \"<div class=\\\"main-content\\\">\\n    <div class=\\\"container-fluid\\\">\\n        <div class=\\\"row\\\">\\n            <div class=\\\"col-md-12\\\">\\n                <h3 class=\\\"text-center\\\">\\n                    World Map<br />\\n                    <small>\\n                        Looks great on any resolution. Made by our friends from jVector Map.\\n                    </small>\\n                </h3>\\n                <div class=\\\"card card-plain\\\">\\n                    <div class=\\\"card-content\\\">\\n                        <div id=\\\"worldMap\\\" class=\\\"map map-big\\\"></div>\\n                    </div>\\n                </div>\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n\";","import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport { RouterModule } from '@angular/router';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\nimport { NguiMapModule} from '@ngui/map';\n\nimport { MapsRoutes } from './maps.routing';\n\nimport { FullScreenMapsComponent } from './fullscreenmap/fullscreenmap.component';\nimport { GoogleMapsComponent } from './googlemaps/googlemaps.component';\nimport { VectorMapsComponent } from './vectormaps/vectormaps.component';\n\n\n@NgModule({\n    imports: [\n        CommonModule,\n        RouterModule.forChild(MapsRoutes),\n        FormsModule,\n        NguiMapModule.forRoot({apiUrl: 'https://maps.google.com/maps/api/js?key=YOUR_KEY_HERE'})\n    ],\n    declarations: [\n        FullScreenMapsComponent,\n        GoogleMapsComponent,\n        VectorMapsComponent\n    ],\n    schemas: [CUSTOM_ELEMENTS_SCHEMA]\n})\n\nexport class MapsModule {}\n"],"sourceRoot":"webpack:///"}